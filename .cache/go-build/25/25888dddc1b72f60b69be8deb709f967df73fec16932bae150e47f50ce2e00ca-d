// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/pi/go/src/github.com/mesilliac/pulse-simple/simple.go:1:1
// pulse-simple wraps PulseAudio's Simple API using cgo,
// for easy audio playback and capture via PulseAudio.
//
// Basic usage is to request a playback or capture stream,
// then write bytes to or read bytes from it.
//
// Reading and writing will block until the given byte slice
// is completely consumed or filled, or an error occurs.
//
// The format of the data will be as requested on stream creation.
//
//  ss := pulse.SampleSpec{pulse.SAMPLE_S16LE, 44100, 2}
//  stream, _ := pulse.Playback("my app", "my stream", &ss)
//  defer stream.Free()
//  defer stream.Drain()
//  stream.Write(data)
//
// More example usage can be found in the examples folder.
//
// For more information, see the PulseAudio Simple API documentation at
// http://www.freedesktop.org/software/pulseaudio/doxygen/simple.html
package pulse

/*
#cgo pkg-config: libpulse-simple

#include <stdlib.h>
#include <pulse/simple.h>
*/
import _ "unsafe"
import "unsafe"

type StreamDirection  /*line :33:22*/_Ctype_pa_stream_direction_t /*line :33:45*/

const (
	STREAM_NODIRECTION StreamDirection = ( /*line :36:39*/_Ciconst_PA_STREAM_NODIRECTION /*line :36:61*/)
	STREAM_PLAYBACK    StreamDirection = ( /*line :37:39*/_Ciconst_PA_STREAM_PLAYBACK /*line :37:58*/)
	STREAM_RECORD      StreamDirection = ( /*line :38:39*/_Ciconst_PA_STREAM_RECORD /*line :38:56*/)
	STREAM_UPLOAD      StreamDirection = ( /*line :39:39*/_Ciconst_PA_STREAM_UPLOAD /*line :39:56*/)
)

type Stream struct {
	simple * /*line :43:10*/_Ctype_pa_simple /*line :43:21*/
}

// Capture creates a new stream for recording and returns its pointer.
func Capture(clientName, streamName string, spec *SampleSpec) (*Stream, error) {
	return NewStream("", clientName, STREAM_RECORD, "", streamName, spec, nil, nil)
}

// Playback creates a new stream for playback and returns its pointer.
func Playback(clientName, streamName string, spec *SampleSpec) (*Stream, error) {
	return NewStream("", clientName, STREAM_PLAYBACK, "", streamName, spec, nil, nil)
}

func NewStream(
	serverName, clientName string,
	dir StreamDirection,
	deviceName, streamName string,
	spec *SampleSpec,
	cmap *ChannelMap,
	battr *BufferAttr,
) (*Stream, error) {

	s := new(Stream)

	var server * /*line :67:14*/_Ctype_char /*line :67:20*/
	if serverName != "" {
		server = ( /*line :69:12*/_Cfunc_CString /*line :69:20*/)(serverName)
		defer func() func() { _cgo0 := /*line :70:16*/unsafe.Pointer(server); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()
	}

	var dev * /*line :73:11*/_Ctype_char /*line :73:17*/
	if deviceName != "" {
		dev = ( /*line :75:9*/_Cfunc_CString /*line :75:17*/)(deviceName)
		defer func() func() { _cgo0 := /*line :76:16*/unsafe.Pointer(dev); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()
	}

	name := ( /*line :79:10*/_Cfunc_CString /*line :79:18*/)(clientName)
	defer func() func() { _cgo0 := /*line :80:15*/unsafe.Pointer(name); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()
	stream_name := ( /*line :81:17*/_Cfunc_CString /*line :81:25*/)(streamName)
	defer func() func() { _cgo0 := /*line :82:15*/unsafe.Pointer(stream_name); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()

	var err  /*line :84:10*/_Ctype_int /*line :84:15*/

	s.simple = ( /*line :86:13*/_Cfunc_pa_simple_new /*line :86:27*/)(
		server,
		name,
		 /*line :89:3*/_Ctype_pa_stream_direction_t /*line :89:26*/(dir),
		dev,
		stream_name,
		spec.toC(),
		cmap.toC(),
		battr.toC(),
		&err,
	)

	if err == ( /*line :98:12*/_Ciconst_PA_OK /*line :98:18*/) {
		return s, nil
	}
	return s, errorFromCode(err)
}

// Stream.Free closes the stream and frees the associated memory.
// The stream becomes invalid after this has been called.
// This should usually be deferred immediately after obtaining a stream.
func (s *Stream) Free() {
	func() { _cgo0 := /*line :108:19*/s.simple; _cgoCheckPointer(_cgo0, nil); _Cfunc_pa_simple_free(_cgo0); }()
}

// Stream.Drain blocks until all buffered data has finished playing.
func (s *Stream) Drain() (error) {
	var err  /*line :113:10*/_Ctype_int /*line :113:15*/
	_ = func() _Ctype_int{ _cgo0 := /*line :114:24*/s.simple; var _cgo1 *_Ctype_int = /*line :114:34*/&err; _cgoCheckPointer(_cgo0, nil); return _Cfunc_pa_simple_drain(_cgo0, _cgo1); }()
	if err == ( /*line :115:12*/_Ciconst_PA_OK /*line :115:18*/) {
		return nil
	}
	return errorFromCode(err)
}

// Stream.Flush flushes the playback buffer, discarding any audio therein
func (s *Stream) Flush() (error) {
	var err  /*line :123:10*/_Ctype_int /*line :123:15*/
	_ = func() _Ctype_int{ _cgo0 := /*line :124:24*/s.simple; var _cgo1 *_Ctype_int = /*line :124:34*/&err; _cgoCheckPointer(_cgo0, nil); return _Cfunc_pa_simple_flush(_cgo0, _cgo1); }()
	if err == ( /*line :125:12*/_Ciconst_PA_OK /*line :125:18*/) {
		return nil
	}
	return errorFromCode(err)
}

// Stream.Write writes the given data to the stream,
// blocking until the data has been written.
func (s *Stream) Write(data []byte) (int, error) {
	var err  /*line :134:10*/_Ctype_int /*line :134:15*/
	_ = func() _Ctype_int{ _cgo0 := /*line :136:3*/s.simple; _cgoIndex1 := &/*line :137:19*/data; _cgo1 := /*line :137:3*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = _Ctype_size_t(len(data)); var _cgo3 *_Ctype_int = /*line :139:3*/&err; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, *_cgoIndex1); return _Cfunc_pa_simple_write(_cgo0, _cgo1, _cgo2, _cgo3); }()
	// pulse simple does not return the number of bytes written,
	// so we must assume that all is written on success,
	// and nothing is written on failure.
	if err == ( /*line :144:12*/_Ciconst_PA_OK /*line :144:18*/) {
		return len(data), nil
	}
	return 0, errorFromCode(err)
}

// Stream.Read reads data from the stream,
// blocking until it has filled the provided slice.
func (s *Stream) Read(data []byte) (int, error) {
	var err  /*line :153:10*/_Ctype_int /*line :153:15*/
	_ = func() _Ctype_int{ _cgo0 := /*line :155:3*/s.simple; _cgoIndex1 := &/*line :156:19*/data; _cgo1 := /*line :156:3*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_size_t = _Ctype_size_t(len(data)); var _cgo3 *_Ctype_int = /*line :158:3*/&err; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, *_cgoIndex1); return _Cfunc_pa_simple_read(_cgo0, _cgo1, _cgo2, _cgo3); }()
	// pulse simple does not return the number of bytes read,
	// so we must assume that all is read on success,
	// and nothing is read on failure.
	if err == ( /*line :163:12*/_Ciconst_PA_OK /*line :163:18*/) {
		return len(data), nil
	}
	return 0, errorFromCode(err)
}

// Stream.Latency returns the playback latency in microseconds.
func (s *Stream) Latency() (uint64, error) {
	var err  /*line :171:10*/_Ctype_int /*line :171:15*/
	lat := func() _Ctype_pa_usec_t{ _cgo0 := /*line :172:33*/s.simple; var _cgo1 *_Ctype_int = /*line :172:43*/&err; _cgoCheckPointer(_cgo0, nil); return _Cfunc_pa_simple_get_latency(_cgo0, _cgo1); }()
	if err == ( /*line :173:12*/_Ciconst_PA_OK /*line :173:18*/) {
		return uint64(lat), nil
	}
	return uint64(lat), errorFromCode(err)
}
