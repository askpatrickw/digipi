// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/pi/go/src/github.com/mesilliac/pulse-simple/sample.go:1:1
package pulse

/*
#cgo pkg-config: libpulse-simple

#include <stdlib.h>
#include <pulse/sample.h>
*/
import _ "unsafe"
import "unsafe"
import "strings"

const (
	CHANNELS_MAX = ( /*line :14:17*/_Ciconst_PA_CHANNELS_MAX /*line :14:33*/) // Maximum number of allowed channels
	RATE_MAX     = ( /*line :15:17*/_Ciconst_PA_RATE_MAX /*line :15:29*/)     // Maximum allowed sample rate
)

type SampleFormat  /*line :18:19*/_Ctype_pa_sample_format_t /*line :18:39*/

const (
	SAMPLE_U8        SampleFormat = ( /*line :21:34*/_Ciconst_PA_SAMPLE_U8 /*line :21:47*/)
	SAMPLE_ALAW      SampleFormat = ( /*line :22:34*/_Ciconst_PA_SAMPLE_ALAW /*line :22:49*/)
	SAMPLE_ULAW      SampleFormat = ( /*line :23:34*/_Ciconst_PA_SAMPLE_ULAW /*line :23:49*/)
	SAMPLE_S16LE     SampleFormat = ( /*line :24:34*/_Ciconst_PA_SAMPLE_S16LE /*line :24:50*/)
	SAMPLE_S16BE     SampleFormat = ( /*line :25:34*/_Ciconst_PA_SAMPLE_S16BE /*line :25:50*/)
	SAMPLE_FLOAT32LE SampleFormat = ( /*line :26:34*/_Ciconst_PA_SAMPLE_FLOAT32LE /*line :26:54*/)
	SAMPLE_FLOAT32BE SampleFormat = ( /*line :27:34*/_Ciconst_PA_SAMPLE_FLOAT32BE /*line :27:54*/)
	SAMPLE_S32LE     SampleFormat = ( /*line :28:34*/_Ciconst_PA_SAMPLE_S32LE /*line :28:50*/)
	SAMPLE_S32BE     SampleFormat = ( /*line :29:34*/_Ciconst_PA_SAMPLE_S32BE /*line :29:50*/)
	SAMPLE_S24LE     SampleFormat = ( /*line :30:34*/_Ciconst_PA_SAMPLE_S24LE /*line :30:50*/)
	SAMPLE_S24BE     SampleFormat = ( /*line :31:34*/_Ciconst_PA_SAMPLE_S24BE /*line :31:50*/)
	SAMPLE_S24_32LE  SampleFormat = ( /*line :32:34*/_Ciconst_PA_SAMPLE_S24_32LE /*line :32:53*/)
	SAMPLE_S24_32BE  SampleFormat = ( /*line :33:34*/_Ciconst_PA_SAMPLE_S24_32BE /*line :33:53*/)
	SAMPLE_MAX       SampleFormat = ( /*line :34:34*/_Ciconst_PA_SAMPLE_MAX /*line :34:48*/)
	SAMPLE_INVALID   SampleFormat = ( /*line :35:34*/_Ciconst_PA_SAMPLE_INVALID /*line :35:52*/)
)

const (
	SAMPLE_S16NE     SampleFormat = ( /*line :39:34*/_Ciconst_PA_SAMPLE_S16NE /*line :39:50*/)
	SAMPLE_FLOAT32NE SampleFormat = ( /*line :40:34*/_Ciconst_PA_SAMPLE_FLOAT32NE /*line :40:54*/)
	SAMPLE_S32NE     SampleFormat = ( /*line :41:34*/_Ciconst_PA_SAMPLE_S32NE /*line :41:50*/)
	SAMPLE_S24NE     SampleFormat = ( /*line :42:34*/_Ciconst_PA_SAMPLE_S24NE /*line :42:50*/)
	SAMPLE_S24_32NE  SampleFormat = ( /*line :43:34*/_Ciconst_PA_SAMPLE_S24_32NE /*line :43:53*/)
	SAMPLE_S16RE     SampleFormat = ( /*line :44:34*/_Ciconst_PA_SAMPLE_S16RE /*line :44:50*/)
	SAMPLE_FLOAT32RE SampleFormat = ( /*line :45:34*/_Ciconst_PA_SAMPLE_FLOAT32RE /*line :45:54*/)
	SAMPLE_S32RE     SampleFormat = ( /*line :46:34*/_Ciconst_PA_SAMPLE_S32RE /*line :46:50*/)
	SAMPLE_S24RE     SampleFormat = ( /*line :47:34*/_Ciconst_PA_SAMPLE_S24RE /*line :47:50*/)
	SAMPLE_S24_32RE  SampleFormat = ( /*line :48:34*/_Ciconst_PA_SAMPLE_S24_32RE /*line :48:53*/)
)

const SAMPLE_FLOAT32 SampleFormat = ( /*line :51:37*/_Ciconst_PA_SAMPLE_FLOAT32 /*line :51:55*/)

type SampleSpec struct {
	Format   SampleFormat
	Rate     uint32
	Channels uint8
}

func (spec *SampleSpec) toC() * /*line :59:32*/_Ctype_pa_sample_spec /*line :59:48*/ {
	if spec == nil {
		return nil
	}
	return & /*line :63:10*/_Ctype_pa_sample_spec /*line :63:26*/{
		format:    /*line :64:13*/_Ctype_pa_sample_format_t /*line :64:33*/(spec.Format),
		rate:      /*line :65:13*/_Ctype_uint32_t /*line :65:23*/(spec.Rate),
		channels:  /*line :66:13*/_Ctype_uint8_t /*line :66:22*/(spec.Channels),
	}
}

func (spec *SampleSpec) fromC(cspec * /*line :70:38*/_Ctype_pa_sample_spec /*line :70:54*/) {
	spec.Format = SampleFormat(cspec.format)
	spec.Rate = uint32(cspec.rate)
	spec.Channels = uint8(cspec.channels)
}

// SampleSpec.BytesPerSecond returns the number of bytes per second of audio.
func (spec *SampleSpec) BytesPerSecond() uint {
	return uint(( /*line :78:14*/_Cfunc_pa_bytes_per_second /*line :78:34*/)(spec.toC()))
}

// SampleSpec.FrameSize returns the size of a single audio frame in bytes.
func (spec *SampleSpec) FrameSize() uint {
	return uint(( /*line :83:14*/_Cfunc_pa_frame_size /*line :83:28*/)(spec.toC()))
}

// SampleSpec.SampleSize returns the size of a single sample in bytes.
func (spec *SampleSpec) SampleSize() uint {
	return uint(( /*line :88:14*/_Cfunc_pa_sample_size /*line :88:29*/)(spec.toC()))
}

// SampleFormat.SampleSize returns the size of a single sample in bytes.
func (f SampleFormat) SampleSize() uint {
	return uint(( /*line :93:14*/_Cfunc_pa_sample_size_of_format /*line :93:39*/)( /*line :93:41*/_Ctype_pa_sample_format_t /*line :93:61*/(f)))
}

// SampleSpec.BytesToUsec returns the number of microseconds taken
// to play the given number of bytes as audio.
//
// The return value will always be rounded down for non-integral values.
func (spec *SampleSpec) BytesToUsec(bytes uint) uint64 {
	return uint64(( /*line :101:16*/_Cfunc_pa_bytes_to_usec /*line :101:33*/)( /*line :101:35*/_Ctype_uint64_t /*line :101:45*/(bytes), spec.toC()))
}

// SampleSpec.UsecToBytes returns the number of bytes required
// for the given number of microseconds of audio.
//
// The return value will always be rounded down for non-integral values.
func (spec *SampleSpec) UsecToBytes(usec uint64) uint {
	return uint(( /*line :109:14*/_Cfunc_pa_usec_to_bytes /*line :109:31*/)( /*line :109:33*/_Ctype_pa_usec_t /*line :109:44*/(usec), spec.toC()))
}

// SampleSpec.Init initializes the SampleSpec to a defined state,
// for which SampleSpec.Valid() will return false.
//
// Calling Init() on a SampleSpec is not necessary,
// but this method is included for compatibility.
func (spec *SampleSpec) Init() {
	spec.fromC(( /*line :118:13*/_Cfunc_pa_sample_spec_init /*line :118:33*/)(spec.toC()))
}

// SampleSpec.Valid returns whether or not the given sample spec is valid.
func (spec *SampleSpec) Valid() bool {
	if ( /*line :123:5*/_Cfunc_pa_sample_spec_valid /*line :123:26*/)(spec.toC()) == 0 {
		return false
	}
	return true
}

// SampleSpec.Equal returns whether or not the given sample specs match.
func (spec *SampleSpec) Equal(other *SampleSpec) bool {
	if ( /*line :131:5*/_Cfunc_pa_sample_spec_equal /*line :131:26*/)(spec.toC(), other.toC()) == 0 {
		return false
	}
	return true
}

// SampleFormat.String returns a string describing the format.
func (f SampleFormat) String() string {
	cstr := ( /*line :139:10*/_Cfunc_pa_sample_format_to_string /*line :139:37*/)( /*line :139:39*/_Ctype_pa_sample_format_t /*line :139:59*/(f))
	return ( /*line :140:9*/_Cfunc_GoString /*line :140:18*/)(cstr)
}

// ParseSampleFormat returns the SampleFormat described by the given string.
//
// The string should be as returned by SampleFormat.String().
func ParseSampleFormat(s string) SampleFormat {
	cstr := ( /*line :147:10*/_Cfunc_CString /*line :147:18*/)(s)
	defer func() func() { _cgo0 := /*line :148:15*/unsafe.Pointer(cstr); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()
	return SampleFormat(( /*line :149:22*/_Cfunc_pa_parse_sample_format /*line :149:45*/)(cstr))
}

// SampleSpec.String returns a human-readable string describing the spec.
func (spec *SampleSpec) String() string {
	s := strings.Repeat(" ", int(( /*line :154:31*/_Ciconst_PA_SAMPLE_SPEC_SNPRINT_MAX /*line :154:58*/)))
	cstr := ( /*line :155:10*/_Cfunc_CString /*line :155:18*/)(s)
	defer func() func() { _cgo0 := /*line :156:15*/unsafe.Pointer(cstr); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()
	( /*line :157:2*/_Cfunc_pa_sample_spec_snprint /*line :157:25*/)(cstr,  /*line :157:33*/_Ctype_size_t /*line :157:41*/(( /*line :157:42*/_Ciconst_PA_SAMPLE_SPEC_SNPRINT_MAX /*line :157:69*/)), spec.toC())
	return ( /*line :158:9*/_Cfunc_GoString /*line :158:18*/)(cstr)
}

/* ** NOT WRAPPED: pa_bytes_snprint **
// Maximum required string length for pa_bytes_snprint(). Please note
// that this value can change with any release without warning and
// without being considered API or ABI breakage. You should not use
// this definition anywhere where it might become part of an
// ABI. \since 0.9.16
#define PA_BYTES_SNPRINT_MAX 11

// Pretty print a byte size value (i.e.\ "2.5 MiB")
char* pa_bytes_snprint(char *s, size_t l, unsigned v);
*/

// SampleFormat.IsLe returns 1 when the format is little endian.
//
// Returns -1 when endianness does not apply to this format.
func (f SampleFormat) IsLe() int {
	return int(( /*line :177:13*/_Cfunc_pa_sample_format_is_le /*line :177:36*/)( /*line :177:38*/_Ctype_pa_sample_format_t /*line :177:58*/(f)))
}

// SampleFormat.IsBe returns 1 when the format is big endian.
//
// Returns -1 when endianness does not apply to this format.
func (f SampleFormat) IsBe() int {
	return int(( /*line :184:13*/_Cfunc_pa_sample_format_is_be /*line :184:36*/)( /*line :184:38*/_Ctype_pa_sample_format_t /*line :184:58*/(f)))
}

// SampleFormat.IsNe returns 1 when the format is native endian.
//
// Returns -1 when endianness does not apply to this format.
func (f SampleFormat) IsNe() int {
	// note: C.pa_sample_format_is_ne() doesn't seem to work
	if SAMPLE_S16NE == SAMPLE_S16LE {
		return int(( /*line :193:14*/_Cfunc_pa_sample_format_is_le /*line :193:37*/)( /*line :193:39*/_Ctype_pa_sample_format_t /*line :193:59*/(f)))
	}
	return int(( /*line :195:13*/_Cfunc_pa_sample_format_is_be /*line :195:36*/)( /*line :195:38*/_Ctype_pa_sample_format_t /*line :195:58*/(f)))
}

// SampleFormat.IsRe returns 1 when the format is reverse endian.
//
// Returns -1 when endianness does not apply to this format.
func (f SampleFormat) IsRe() int {
	// note: C.pa_sample_format_is_re() doesn't seem to work
	if SAMPLE_S16NE == SAMPLE_S16LE {
		return int(( /*line :204:14*/_Cfunc_pa_sample_format_is_be /*line :204:37*/)( /*line :204:39*/_Ctype_pa_sample_format_t /*line :204:59*/(f)))
	}
	return int(( /*line :206:13*/_Cfunc_pa_sample_format_is_le /*line :206:36*/)( /*line :206:38*/_Ctype_pa_sample_format_t /*line :206:58*/(f)))
}
